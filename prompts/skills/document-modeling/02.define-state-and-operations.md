# DM.02 Create the state schema and operations

Make extensive use of the `active-project-vetra` MCP tool for this scenario DM.02. 
Do not make any changes in the code yet. We are still only editing the specification document.

Recall the best practices on how to create document model state schemas and operations.

## DM.02.1 Define the global state schema

### Reread the document description and come up with an extended version with more detail
  
  - Take the scope restrictions into account but don't include them in the extended description
  
  - Consider example data

  - Describe in more detail what the users can do with the data
    - Consider creation, modification, sorting/moving and removal of data objects
    - Consider actions with more advanced business logic
    - Consider workflow status transitions

  - Consider the relationship between the document you're creating and other document types
    - While documents must always be self-contained data structures, other documents can 
      be referenced with a `PHID` and, typically, a number of cached properties. 

### Example

If the original document description reads like this: 

```
The Pizza Plaza order document will be used by the restaurant owner, their customers and the kitchen chefs. 
The restaurant owner will prepare the document by defining the menu categories, options and prices in it. 
The customer will then use this menu to add the pizzas, sides and drinks they want to order to their basket. 
They will see the itemized prices and the total. Once the order is placed, a kitchen chef will check off the
items one by one as ready.

The order document does not support customization options for the items and it does not track the entire lifecycle
of payment, delivery, etc. It is meant to be a reliable reference for what the restaurant offers, what the customers 
wants, and what the kitchen has prepared.
```

An extended version can be this: 

```md
The Pizza Plaza order document will be used by the restaurant owner, their customers and the kitchen chefs. 
The restaurant owner will prepare the document by defining the menu categories, options and prices in it.

Example categories are 'Small Pizzas', 'Medium Pizzas', 'Large Pizzas', 'Sides', and 'Drinks'. The restaurant 
owner will define them simply with a label, and sort them in the right order. The category options are the actual 
products such as 'Peperoni Pizza', which should have a name, picture URL, short description sentence, and a 
unit price. The restaurant owner can create and edit the product details, and they can order the products within 
the category, and they can delete products.

The customer will then use this menu to add the pizzas, sides and drinks they want to order to their basket. They can 
update the amount and remove products from their basket. They cannot add the same product to their basket twice. They 
cannot change the order of the products in their basket. The products will simply appear in the same order as in the menu.

Customers will see the itemized prices and the total price of each basket line item. The restaurant owner will set a 
tax rate on each product category, which will also be applied. Overall we're keeping track of unit price excl. taxes, 
unit price incl. taxes, subtotal excl. taxes and subtotal incl. taxes, basket total excl. taxes, basket tax total per 
tax rate, and basket total incl. taxes. 

Customers can clear their entire basket and start over. They can add additional notes to the order, which they can do
to communicate for example allergies or delivery instructions.

**Workflow**

The document workflow enforces menu creation first, which is then locked down. As a second phase the customer will fill
their basket and confirm. Once confirmed, the basket can no longer be edited and the kitch chef will check off the items.
Once all items are checked off, the order document is fulfilled. It is possible to go back to menu editing but then the 
basket will be automatically cleared. There should be timestamps for each one of the status transitions.

**External documents**

The shop owner will reference a `pizza-plaza/point-of-sale` document in the `pizza-plaza/order` document, from where the
local name, company ID, address and telephone number will be cached.
```

### Extract an initial state schema from the extended description

  **State Schema Root Type**

  - **CRITICAL** There is always a single root type called <DocumentModelName>State which is required
    to be the PascalCase version of the document name. Failing to apply this pattern will break the 
    code generator later on.

    For example: if the document model name is `Pizza Plaza Order`, its root type name is `PizzaPlazaOrderState`

  - The root type must not have an ID field (OID or PHID), because the document header already contains an
    ID. However, it may contain a business logic code or reference that the user would use as document identifier.

    For example: Pizza Plaza needs an _order id_ for their accounting. This should be a `String` field or another
    appropriate scalar type, but not an `OID` or `PHID`, for example `orderRef: String`.

  **OIDs and PHIDs**

  - All objects in collections (arrays) MUST HAVE an `id: OID!`. `OID` fields are used both as "primary key" and 
    "foreign key reference". Good practice is to call the property `id` if it's a primary key, and call it 
    `otherObjectId: OID!` if it's a foreign key, with a comment to define which object types it can reference.

  - Use the `PHID` only to reference external documents if needed and identify the cached data properties 
    that are needed. 
    
    "Cached data property" simply means that a number of properties will be set together with the 
    external document id so that the user can understand what was in the external document at the time when 
    the PHID field was set. These data properties can get out-of-date, so the system will need to ensure it's 
    updated when it matters.

    This is the same principle as the title and snippet information in HTML links and social media preview cards: 
    ```html
    <a href="http://example.com/document.html">
      <img src="..." alt="cached image"/>
      <p>Cached description that may be out-of-date</p>
    </a>
    ```
  
  - The `ID` type which is a wider common practice in GraphQL, is not used. 

  - Always use `enum` types for workflow statuses.

  **When to use mandatory and optional state fields**

  Mandatory properties in a state and operation input schema are indicated with an exclamation mark, e.g. `id: OID!`. 

  Note that the reasoning about when to use mandatory fields in the state schema is quite different from the reasoning 
  about operation input schemas. We're only concerned with the former, in this section.

  - **IMPORTANT** A user must always be able to create an empty document _without_ providing any information, and the state
    schema needs to cover the entire life cycle of the document. This means that, in the root type, _properties can only be mandatory if they have a logical default value_!

    For example, one might think: "A Pizza Plaza order always needs an order ID for their accounting, make it mandatory", 
    but this overlooks the fact that the restaurant owner must be able to create an empty order document in the first place.
    Order ID in this case also does not have a logical default, because it has to be unique in the system. Therefore, 
    the `orderRef: String` field should definitely not be mandatory.

  - Collections, ie. array types, should always use double exclamation marks like `lines: [BasketLine!]!`. The inner 
    exclamation mark simply expresses that array items should never be a NULL value, which is always the case. The outer
    exclamation mark indicates that at least an empty array should always be set as value of the collection, as opposed to
    `lines = null`. Following our rule, this is almost always a very logical default.

  - Another situation with a common 'logical default' is in the case of a child objects. In our Pizza Plaza order example,
    the `menu: Menu!` should always _exist_, although it should be empty in the beginning. Note that this can only be done 
    if the child object also has a logical empty default -- mandatory properties of the child object may prevent us from 
    setting the 

    The customer basket, however, may logically only come into existence when the document moves on to the "BASKET_EDITING"
    phase. Therefore it could be made optional as a design decision to reflect the lifecycle business logic: `basket: Basket`

  **Collection sorting**

  - There is no need to use a `position` or `weight` property to sort items in a collection. The items must be kept ordered
    in the array via their index. 

  - Since all collection objects have an `id: OID!`, moving and sorting operations can defined as
    `SORT(ids: [OID!]!, insertBefore: OID!)`. This is a best practice that creates operations that have good branching and
    merging behavior too. 

  **Trees and Recursion** 

  - Always define trees as a flat list, e.g. `TreeNodeType { id:OID!, parentId:OID }`, whereby root nodes have `parentId=null`

  - During reducer impelementation, it's good practice to have a sorting helper function that deterministically sorts the tree
    nodes, e.g. dept-first, and apply this helper function in every reducer that manipulates the tree structure.

### Example

The intial state schema could be like this:

```graphql

type PizzaPlazaOrderState {
  status: OrderStatus!          # default = MENU_EDITING
  pos: PointOfSaleInfo          # mandatory child properties make this optional
  menu: Menu!                   # default = empty menu
  basket: Basket                # does not exist until status = BASKET_EDITING
  customerNotes: String         # optional
  timestamps: OrderTimestamps!  # default = empty timestamps
}

enum OrderStatus {
  MENU_EDITING
  BASKET_EDITING
  BASKET_CONFIRMED
  ORDER_FULFILLED
}

type PointOfSaleInfo {
  docId: PHID!                  # references pizza-plaza/point-of-sale document
  name: String!                 # cached property
  companyID: String!            # cached property
  address: String               # cached property
  telephone: String             # cached property
}

type OrderTimestamps {
  menuCreatedAt: DateTime
  basketConfirmedAt: DateTime
  orderFulfilledAt: DateTime
}

type Menu {
  categories: [MenuCategory!]!
}

type MenuCategory {
  id: OID!
  label: String!
  taxRate: Float!
  items: [MenuItem!]!
}

type MenuItem {
  id: OID!
  status: MenuItemStatus!
  name: String!
  pictureUrl: URL
  description: String
  unitPriceInclTax: Float!
}

enum MenuItemStatus {
  DRAFT,
  AVAILABLE, 
  OUT_OF_STOCK
}

type Basket {
  lines: [BasketLine!]!
  totals: BasketTotals!
}

type BasketLine {
  id: OID!                  # Primary Key
  itemId: OID!              # Foreign Key: MenuItem.id
  quantity: Int!
  unitPriceExclTax: Float!
  unitPriceInclTax: Float!
  subtotalExclTax: Float!
  subtotalInclTax: Float!
  categoryTaxRate: Float!
  preparedByKitchen: Boolean!
}

type BasketTotals {
  totalExclTax: Float!
  taxBreakdown: [TaxRateTotal!]!
  totalInclTax: Float!
}

type TaxRateTotal {
  taxRate: Float!
  taxAmount: Float!
}
```

### Wrap-up

- Add the extended description to the WBS notes
- Ensure that the state schema is set in the document model spec using `active-project-vetra`, for the `global` scope
- Verify the document is correctly updated

### Expected Outcome

The state schema of the document model is created following best-practice rules and written to the spec.

## DM.02.2 Generate a minimal default value for the document

Create a JSON object that complies to the root object type with only the mandatory properties filled.

### Example

Our empty `pizza-plaza/order` document would look as follows:

```json
{
  "status": "MENU_EDITING",
  "pos": null,
  "menu": {
    "categories": []
  },
  "basket": null,
  "customerNotes": null,
  "timestamps": {
    "menuCreatedAt": null,
    "basketConfirmedAt": null,
    "orderFulfilledAt": null
  }
}
```

### Wrap-up

- Ensure that the default JSON is set in the document model spec using `active-project-vetra`, 
  for the `global` scope

- Verify the document is correctly updated

### Expected Outcome

- The default value JSON is available in the document and complies to the state schema

## DM.02.3 Define the modules and operations

Define the document model modules to group operations.

Recall your best practices and apply them. Begin by setting the operation names. 
Then consider the following for their input types: 

### CRITICAL: Input root type name

  - The input root type name must always be `<OperationName>Input` where `<OperationName>` is the pascal case version
    of the operation name. For example: the `SET_CATEGORY_LABEL` operation would have `SetCategoryLabelInput` as root 
    input type. 

  - Failing to apply this rule will break compilation later.

### CRITICAL: Getting type references right

- In the operation input schema, **ONLY** `enum` types (and scalars) from the state schema can be used. All other types
  are read model types and cannot be referenced as input types.

- Instead, consider creating additional input types to mirror the state schema types, but appreciate the differences,
  especially in the rules for mandatory properties. State schema enum types MUST NOT be redefined in the input types. 
  Doing so will result in compiler errors; they should just be used directly.

- Don't reuse the mirror input types either. Think of each input type as unique to its own operation.

### Knowing when to use mandatory / optional input type properties

Input types are about _user intent and the mutation that will be applied_. As such, properties in input types should 
often be mandatory or optional, even if they are (not) optional in the state schema. Optional input properties that are 
set to null are either interpreted as "not included in the input" (add/patch-like operation) or could mean "clear this 
value in the state."

- Due to this ambiguity and also because clearing data often should have a separate permission associated, it's often
  advisable to create a separate `CLEAR_PROPERTY` operation. 

- For example: the `pizza-plaza/order` state schema has an optional `orderRef: String` state property because the order 
  reference won't be set when the empty document is first created. 

  - However, the `SET_ORDER_REF` operation's input type requires an orderRef parameter because, once set, the orderRef
    should generally not be cleared.

  - Should the requirement come up that an order ref, in fact, should be cleared in some cases, an additional 
    `CLEAR_ORDER_REF` operation should be added.

### Example 

If Pizza Plaza's state schema looks like this:

```graphql
type MenuCategory {
  id: OID!
  items: [MenuItem!]!
}

type MenuItem {
  id: OID!
  status: MenuItemStatus!
  name: String!
  picture: URL
}

enum MenuItemStatus {
  DRAFT,
  AVAILABLE, 
  OUT_OF_STOCK
}
```

We could have operations `ADD_CATEGORY_MENU_ITEMS`, `UPDATE_CATEGORY_MENU_ITEMS` and `CLEAR_MENU_ITEM_PICTURE` with input types: 

```graphql
"Operation: ADD_CATEGORY_MENU_ITEMS"
input AddCategoryMenuItemsInput {
  categoryId: OID!
  items: [NewMenuItemInput!]!   # we MUST NOT reference the MenuItem state type, instead we mirror with 
                                # a unique input type, NewMenuItemInput
}

input NewMenuItemInput {
  id: OID!                      # new item's OID, always required to keep the reducers pure

  status: MenuItemStatus        # enum state type _is_ available -- we can use it, MUST NOT redefine it
                                # default = AVAILABLE -- optional input, mandatory state value

  name: String!                 # no default, mandatory as the state value
  picture: URL                  # no default, optional as the state value
}

"Operation: UPDATE_CATEGORY_MENU_ITEMS"
input UpdateCategoryMenuItemsInput {
  categoryId: OID!
  items: [MenuItemUpdateInput!]! # we MUST NOT reference the MenuItem state type, or input type NewMenuItemInput 
                                 # instead we mirror with a unique input type, MenuItemUpdateInput
}

input MenuItemUpdateInput {
  id: OID!                      # existing item's OID
  status: MenuItemStatus        # enum state type _is_ available -- we can use it, MUST NOT redefine it
                                # default = no update
  name: String                  # default = no update
  picture: URL                  # default = no update
}

"Operation: CLEAR_MENU_ITEM_PICTURE"
input ClearMenuItemPictureInput {
  menuItemId: OID!
}
```

### Wrap-up

- Ensure that all modules, operations and their input types have been added to the document model 
  spec via `active-project-vetra`, for the `global` scope

- Verify the document is correctly updated

- Verify that the code generator has been correctly triggered at this point

### Expected Outcome

Document model operations and their input types are now available in the document model spec in Vetra drive.