=== BEGIN SKILL BRIEFING === 

IMPORTANT:  Don't take any action yet. You will be guided through your tasks after the briefing(s). Just process and confirm your understanding.

# Document Modeling - Skill Preamble

With this skill, you can design and implement new Reactor 'document model' modules for the Powerhouse ecosystem. Your role is to work for stakeholders 
by creating these modules based on their needs. This briefing teaches you about general document modeling practices. Refer to specific tasks before 
applying the relevant portions of this information. 

## Document Model Creation Principles

### 1. Planning

**MANDATORY**: Present your proposal to the user and ask for confirmation before implementing ANY document model.

- **ALWAYS** describe the proposed document model structure (state schema, operations, modules) before creating
- **NEVER** proceed with implementation without explicit user approval of your proposal
- When in doubt, ask for clarification
- Break complex models into logical modules and operations

### 2. Pre-Implementation Requirements

**MANDATORY**: Check document model schema before making any MCP tool calls.

- **ALWAYS** use `mcp__active-project-vetra__getDocumentModelSchema` with `type: "powerhouse/document-model"` first
- Review input schema requirements for operations like `ADD_MODULE`, `ADD_OPERATION`, etc.
- Ensure all required parameters (like `id` or `scope` fields) are included in action inputs
- This prevents failed tool calls and reduces iteration

### 3. Implementation Requirements

- Document model reducers must be **pure synchronous functions**
- Reducers receive current state and operation, always returning the same result
- Values like dates/IDs must come from operation input, not generated in reducer
- Reducer code goes into SET_OPERATION_REDUCER action (no function header needed)
- Reducers are wrapped with Mutative - you can mutate the state object directly
- External imports go at the beginning of the actual reducer file in `src/`
- Ensure that the reducer code of each operation in the document model schema is applied in `document-models/<document-model-name>/src/reducers/<module-name>.ts`

### 4. Quality assurance

After doing changes to the code, or after creating a new document model or a new editor, _YOU MUST RUN_ the following commands to check for errors in your implementation:

- **TypeScript Check**: Run `npm run tsc` to validate type safety
- **ESLint Check**: Run `npm run lint:fix` to check for errors with ESLint

## Best Practices 

### Scope Selection

- **`scope: "global"`**: State shared among all users with document access
- **`scope: "local"`**: State private to each individual user

### Operation Design

- Use descriptive operation names (e.g., `ADD_LINE_ITEM`, `UPDATE_RECIPIENT`)
- One operation per user intent (separate concerns)
- Include comprehensive examples and error definitions
- Organize related operations into logical modules

## Reducer Implementation Guidelines

### ❌ Forbidden in Reducers (Non-Deterministic)

- `crypto.randomUUID()`, `Math.random()`, `Date.now()`, `new Date()`
- External API calls or side effects
- Asynchronous functions
- Any non-deterministic functions

### ❌ Forbidden Patterns

```typescript
// NEVER use fallback values with non-deterministic functions
id: action.input.id || crypto.randomUUID(); // ❌ FORBIDDEN
timestamp: action.input.timestamp || new Date(); // ❌ FORBIDDEN
```

### ✅ Required Pattern

All dynamic values must come from action input:

- **IDs**: Include `id: OID!` in input schema, use `action.input.id` in reducer
- **Timestamps**: Include `timestamp: DateTime!` in input schema
- **Computed values**: Calculate before dispatching action

### Example

```typescript
// ❌ BAD - impure reducer
const newItem = {
  id: crypto.randomUUID(), // Non-deterministic
  createdAt: new Date(), // Non-deterministic
};

// ✅ GOOD - pure reducer
const newItem = {
  id: action.input.id, // From action input
  createdAt: action.input.createdAt, // From action input
};
```

### Handling Nullable Input Types

**CRITICAL**: Be careful when handling optional input types:

- Optional input types use `InputMaybe<T>` allowing `null | undefined | T`.
- Optional state types use `Maybe<T>` = `T | null`.
- If there is no applicable default value then use `|| null`.

```typescript
// ❌ BAD - Type error with Maybe<string>
amount: action.input.amount,
notes: action.input.notes,

// ✅ GOOD - Matches Maybe<T> = T | null
amount: action.input.amount || null,
notes: action.input.notes || [],
```

Use truthy checks when conditionally assigning optional values from input to state:

```typescript
// ❌ BAD - Type 'string | null' is not assignable to type 'string'.
if (action.input.field !== undefined) entry.field = action.input.field;

// ✅ GOOD - use truthy checks
if (action.input.field) state.field = action.input.field;

// ✅ GOOD - For booleans use explicit null/undefined checks
if (action.input.field !== undefined && action.input.field !== null)
  state.field = action.input.field;
```

## GraphQL Schema Guidelines

### Document State Schema

- **Most fields optional** to support creating empty documents
- Use required fields `!` only when absolutely necessary
- Defaults handled by operations, not schema

### ⚠️ CRITICAL: State Type Naming Convention

**MANDATORY**: The global state type name MUST follow this exact pattern:

```graphql
type <DocumentModelName>State {
    # your fields here
}
```

**DO NOT** append "Global" to the state type name, even when defining global state:

```graphql
// ❌ WRONG - Do not use "GlobalState" suffix
type TodoListGlobalState {
    todos: [Todo!]!
}

// ✅ CORRECT - Use only "State" suffix
type TodoListState {
    todos: [Todo!]!
}

// ✅ CORRECT - Use "LocalState" suffix for Local scope
type TodoListLocalState {
    localTodos: [Todo!]!
}
```

**Why this matters:**

- The code generator expects the type to be named `<DocumentModelName>State`
- Using `GlobalState` or `LocalState` suffix will cause TypeScript compilation errors
- This applies when using `SET_STATE_SCHEMA` with `scope: "global"`

**Rule**: For global state, the type should be `<DocumentModelName>State`. For local state (if needed), the type name should be `<DocumentModelName>LocalState`.

### Available Scalar Types

| Standard  | Custom Identity                   | Custom Amounts      | Custom Specialized |
| --------- | --------------------------------- | ------------------- | ------------------ |
| `String`  | `OID` (Object ID)                 | `Amount`            | `EthereumAddress`  |
| `Int`     | `PHID` (Powerhouse document ID)   | `Amount_Tokens`     | `EmailAddress`     |
| `Float`   | `OLabel`                          | `Amount_Money`      | `Date`             |
| `Boolean` |                                   | `Amount_Fiat`       | `DateTime`         |
|           |                                   | `Amount_Currency`   | `URL`              |
|           |                                   | `Amount_Crypto`     | `Currency`         |
|           |                                   | `Amount_Percentage` |                    |

### Arrays and Objects

- **Arrays**: Must be mandatory `[ObjectType!]!`
- **Objects in arrays**: Must include `id: OID!` field for unique identification
- Include `OLabel` for metadata when relevant

### Input Types

- Reflect user intent with descriptive names
- Simple, specific fields over complex nested types

## Error Handling in Operations

**MANDATORY**: Define specific error types for each operation to handle invalid inputs and edge cases properly.
Action inputs are validated so they are guaranteed to respect the input schema.
Errors referenced in the reducer code will be imported automatically.

### Error Definition Requirements

1. **Add error definitions** to operations using `ADD_OPERATION_ERROR`:

   - `code`: Uppercase snake_case (e.g., `"MISSING_ID"`, `"ENTRY_NOT_FOUND"`)
   - `name`: PascalCase ending with "Error" (e.g., `"MissingIdError"`, `"EntryNotFoundError"`)
   - `description`: Human-readable description of the error condition

2. **Error names must end with "Error"** for consistency and code generation

3. **Use specific error types** rather than generic validation

4. **Must use unique error names and ids**

### Error Usage in Reducers

```typescript
// ✅ GOOD - Throw specific errors by name
if (!action.input.id) {
  throw new MissingIdError("ID is required for operation");
}

if (entryIndex === -1) {
  throw new EntryNotFoundError(`Entry with ID ${action.input.id} not found`);
}

// ❌ BAD - Generic Error
throw new Error("Something went wrong");

// ❌ BAD - Nested error access
throw new errors.ModuleName.MissingIdError("message");

// ❌ BAD - Do not import error classes in the reducer code,
import { MissingIdError } from "../../gen/module-name/error.js";

// ✅ GOOD - Simply reference the error and it will be imported automatically
throw new MissingIdError("message");
```

### Common Error Patterns

- **EntityNotFoundError**: Referenced entity doesn't exist
- **DuplicateIdError**: ID already exists when creating new entries
- **InvalidInputError**: Business logic violations
- **PermissionDeniedError**: Access control violations

## ⚠️ CRITICAL: Generated Files & Modification Rules

### Generated Files Rule

**NEVER edit files in `gen/` folders** - they are auto-generated and will be overwritten.

### Document Model Modification Process

For ANY document model changes, follow this **mandatory** two-step process:

#### Step 1: Update Document Model via MCP

Use `mcp__active-project-vetra__addActions` with operations like:

- `SET_OPERATION_SCHEMA` - update input/output schemas
- `SET_OPERATION_REDUCER` - update reducer code
- `SET_STATE_SCHEMA` - update state definitions

#### Step 2: Update Existing Source Files

**ALSO manually update existing reducer files in `src/` folder** - these are NOT auto-generated.
Make sure to check if the operation reducer code needs to be updated after changing the state schema.

### ⚠️ Critical Reminder

**ALWAYS do BOTH steps when fixing reducer issues:**

1. ✅ Fix existing reducer files in `src/` manually
2. ✅ Update document model via MCP with same fixes

**Forgetting step 2 means future code generations will still contain the bugs!**

# Notes

Note on task management: 
- The creation of a new document model is associated with a single goal/task in your WBS document.
- Add notes to remember your progress and update the goal status in your WBS document as you go along.

=== END OF SKILL BRIEFING ===